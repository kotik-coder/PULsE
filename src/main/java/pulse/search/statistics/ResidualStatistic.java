package pulse.search.statistics;

import static java.lang.Math.max;
import static java.lang.Math.min;
import static pulse.input.IndexRange.closestLeft;
import static pulse.input.IndexRange.closestRight;
import static pulse.properties.NumericProperties.derive;
import static pulse.properties.NumericProperty.requireType;
import static pulse.properties.NumericPropertyKeyword.OPTIMISER_STATISTIC;

import java.util.ArrayList;
import java.util.List;

import pulse.properties.NumericProperty;
import pulse.properties.NumericPropertyKeyword;
import pulse.tasks.SearchTask;

/**
 * An abstract statistic (= a numeric value resulting from a statistical
 * procedure) that operates with model residuals. The list of residuals is
 * stored in a field value for objects of this class. Each {@code SearchTask}
 * will have at least two {@code ResidualStatistic}s associated with its
 * {@code Calculation}s.
 *
 * @see pulse.tasks.SearchTask
 * @see pulse.tasks.Calculation
 *
 */
public abstract class ResidualStatistic extends Statistic {

    private double statistic;
    private List<double[]> residuals;

    public ResidualStatistic() {
        super();
        residuals = new ArrayList<>();
        setPrefix("Residuals");
    }

    public ResidualStatistic(ResidualStatistic another) {
        this.statistic = another.statistic;
        this.residuals = new ArrayList<>(another.residuals);
    }

    public double[] transformResiduals() {
        return getResiduals().stream().mapToDouble(doubleArray -> doubleArray[1]).toArray();
    }

    /**
     * This will calculate the residuals for the {@code task} using the time
     * sequence defined by the {@code ExperimentalData} object. The residuals
     * are calculated between the model, which was previously used to populate
     * the {@code HeatingCurve} and the experimental data. The temperature value
     * of the model at the reference time is
     * <math><msub><mi>t</mi><mi>i</mi></msub></math>. and unknown <i>a
     * priori</i>. Therefore, it needs to be interpolated based on the discrete
     * dataset generated by the solver. The interpolation is currently done
     * using natural cubic splines, which are re-constructed each time a new
     * solution is generated. Therefore, calling this method does not involve
     * expensive calculation of the spline coefficents. The residuals are
     * calculated only for the range that is specified by the
     * {@code ExperimentalData} reference. The output of this method is stored
     * in the field of the {@code residuals} object.
     *
     * @param task the optimisation task
     * @see pulse.input.ExperimentalData
     * @see pulse.HeatingCurve
     */
    public void calculateResiduals(SearchTask task) {
        var estimate = task.getCurrentCalculation().getProblem().getHeatingCurve();
        var reference = task.getExperimentalCurve();

        residuals.clear();
        var indexRange = reference.getIndexRange();
        var time = reference.getTimeSequence();

        var s = estimate.getSplineInterpolation();

        int startIndex = max(closestLeft(estimate.timeAt(0), time), indexRange.getLowerBound());
        int endIndex = min(closestRight(estimate.timeLimit(), time), indexRange.getUpperBound());

        double interpolated;

        for (int i = startIndex; i <= endIndex; i++) {
            /*
			 * find the point on the calculated heating curve which has the closest time
			 * value smaller than the experimental points' time value
             */

            interpolated = s.value(reference.timeAt(i));

            residuals.add(new double[]{reference.timeAt(i),
                reference.signalAt(i) - interpolated}); // y_exp - y*

        }

    }

    public List<double[]> getResiduals() {
        return residuals;
    }

    public double residualUpperBound() {
        return residuals.stream().map(array -> array[1]).reduce((a, b) -> b > a ? b : a).get();
    }

    public double residualLowerBound() {
        return residuals.stream().map(array -> array[1]).reduce((a, b) -> a < b ? a : b).get();
    }

    public NumericProperty getStatistic() {
        return derive(OPTIMISER_STATISTIC, statistic);
    }

    public void setStatistic(NumericProperty statistic) {
        requireType(statistic, OPTIMISER_STATISTIC);
        this.statistic = (double) statistic.getValue();
    }

    public void incrementStatistic(final double increment) {
        this.statistic += increment;
    }

    @Override
    public void set(NumericPropertyKeyword type, NumericProperty property) {
        if (type == OPTIMISER_STATISTIC) {
            statistic = (double) property.getValue();
        }
    }

}
