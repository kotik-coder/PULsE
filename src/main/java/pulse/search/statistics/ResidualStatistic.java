package pulse.search.statistics;

import java.util.ArrayList;
import static pulse.properties.NumericProperties.derive;
import static pulse.properties.NumericProperty.requireType;
import static pulse.properties.NumericPropertyKeyword.OPTIMISER_STATISTIC;

import java.util.List;
import pulse.DiscreteInput;
import pulse.Response;
import pulse.input.IndexRange;

import pulse.properties.NumericProperty;
import pulse.properties.NumericPropertyKeyword;
import pulse.search.GeneralTask;

/**
 * An abstract statistic (= a numeric value resulting from a statistical
 * procedure) that operates with model residuals. The list of residuals is
 * stored in a field value for objects of this class. Each {@code SearchTask}
 * will have at least two {@code ResidualStatistic}s associated with its
 * {@code Calculation}s.
 *
 * @see pulse.tasks.SearchTask
 * @see pulse.tasks.Calculation
 *
 */
public abstract class ResidualStatistic extends Statistic {

    private double statistic;
    private List<Double> rx;
    private List<Double> ry;

    public ResidualStatistic() {
        super();
        ry = new ArrayList<>();
        rx = new ArrayList<>();
        setPrefix("Residuals");
    }

    public ResidualStatistic(ResidualStatistic another) {
        this.statistic = another.statistic;
        ry = new ArrayList<>();
        rx = new ArrayList<>();
    }

    /**
     * This will calculate the residuals for the {@code task} using the time
     * sequence defined by the {@code ExperimentalData} object.The residuals are
     * calculated between the model, which was previously used to populate the
     * {@code HeatingCurve}and the experimental data.The temperature value of
     * the model at the reference time is
     * <math><msub><mi>t</mi><mi>i</mi></msub></math>.and unknown <i>a
     * priori</i>. Therefore, it needs to be interpolated based on the discrete
     * dataset generated by the solver. The interpolation is currently done
     * using natural cubic splines, which are re-constructed each time a new
     * solution is generated. Therefore, calling this method does not involve
     * expensive calculation of the spline coefficents. The residuals are
     * calculated only for the range that is specified by the
     * {@code ExperimentalData} reference. The output of this method is stored
     * in the field of the {@code residuals} object.
     *
     * @param reference
     * @param estimate
     * @see pulse.input.ExperimentalData
     * @see pulse.HeatingCurve
     */
    public final void calculateResiduals(DiscreteInput reference, Response estimate, int min, int max) {
        var y = reference.getY();
        var x = reference.getX();
   
        //if size has not changed, use the old list
        
        if (ry.size() == max - min + 1) {

            for (int i = min; i < max; i++) {

                ry.set(i - min, y.get(i) - estimate.evaluate(x.get(i)));

            }

        } 
        
        //else create a new list
        
        else {

            rx = x.subList(min, max);
            ry.clear();

            for (int i = min; i < max; i++) {

                ry.add(y.get(i) - estimate.evaluate(x.get(i)));

            }

        }

    }
    
    public void calculateResiduals(DiscreteInput reference, Response estimate) {
        var y = reference.getY();
        var x = reference.getX();
     
        var estimateRange = estimate.accessibleRange();

        int min = (int) Math.max(reference.getIndexRange().getLowerBound(),
                IndexRange.closestLeft(estimateRange.getMinimum(), x) );
        int max = (int) Math.min(reference.getIndexRange().getUpperBound(),
                IndexRange.closestRight(estimateRange.getMaximum(), x) );
  
        calculateResiduals(reference, estimate, min, max);
    }

    public double[] residualsArray() {
        return ry.stream().mapToDouble(d -> d).toArray();
    }

    public final void calculateResiduals(GeneralTask task) {
        calculateResiduals(task.getInput(), task.getResponse());
    }

    public List<Double> getResiduals() {
        return ry;
    }

    public List<Double> getTimeSequence() {
        return rx;
    }

    public NumericProperty getStatistic() {
        return derive(OPTIMISER_STATISTIC, statistic);
    }

    public void setStatistic(NumericProperty statistic) {
        requireType(statistic, OPTIMISER_STATISTIC);
        this.statistic = (double) statistic.getValue();
    }

    @Override
    public void set(NumericPropertyKeyword type, NumericProperty property) {
        if (type == OPTIMISER_STATISTIC) {
            statistic = (double) property.getValue();
        }
    }

}
